# -*- coding: utf-8 -*-
"""Imers√£o IA Alura + Google Gemini - Projeto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CBTA6mfJKRHD8lKtY9_c0PtxFDFptCZO
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip -q install google-genai

# Configura a API Key do Google Gemini

import os
from google.colab import userdata

os.environ["GOOGLE_API_KEY"] = userdata.get('GOOGLE_API_KEY')

# Configura o cliente da SDK do Gemini
from google import genai
client = genai.Client()
MODEL_ID = "gemini-2.0-flash"

# Instalar Framework de agentes do Google ################################################
!pip install -q google-adk

from google.colab import userdata
from google.adk.agents import Agent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.tools import google_search
from google.genai import types
import textwrap
from IPython.display import display, Markdown, HTML
import json
import re # valida√ß√£o de ingredientes

# --- Fun√ß√µes Auxiliares ---
def call_agent(agent: Agent, message_text: str) -> str:
    session_service = InMemorySessionService()
    session = session_service.create_session(app_name=agent.name, user_id="user1", session_id="session1")
    runner = Runner(agent=agent, app_name=agent.name, session_service=session_service)
    content = types.Content(role="user", parts=[types.Part(text=message_text)])

    final_response_parts = []
    for event in runner.run(user_id="user1", session_id="session1", new_message=content):
        if event.is_final_response():
          for part in event.content.parts:
            if part.text is not None:
              final_response_parts.append(part.text)

    raw_response = "".join(final_response_parts)

    # Remove blocos de c√≥digo markdown como ```json\n...\n```
    if raw_response.strip().startswith("```json") and raw_response.strip().endswith("```"):
        raw_response = raw_response.strip()[len("```json"):]
        raw_response = raw_response.strip()[:-len("```")]
        raw_response = raw_response.strip() # Limpa espa√ßos em branco extras
    elif raw_response.strip().startswith("```") and raw_response.strip().endswith("```"): # Caso o modelo retorne apenas ``` (sem json)
        raw_response = raw_response.strip()[len("```"):]
        raw_response = raw_response.strip()[:-len("```")]
        raw_response = raw_response.strip() # Limpa espa√ßos em branco extras

    return raw_response # Retorna a resposta limpa.

def to_markdown(text):
  text = text.replace('‚Ä¢', '  *')
  return Markdown(textwrap.indent(text, '> ', predicate=lambda _: True))

#######################################################
# --- Agente 1: Coleta e Processamento de Ingredientes --- #
#######################################################
def agente_coleta_ingredientes(texto_ingredientes: str):
    agente_processador = Agent(
        name="agente_coleta_ingredientes",
        model=MODEL_ID,
        instruction="""
        Voc√™ √© um processador de texto especialista em identificar ingredientes e, opcionalmente, suas quantidades.
        Sua tarefa √© extrair os nomes dos ingredientes e suas quantidades (se houver) de uma frase de texto livre.
        Se a quantidade n√£o for mencionada, assuma que a quantidade √© 'suficiente' e marque como null.
        Normalizar os nomes dos ingredientes para o singular e min√∫sculas.
        Sua sa√≠da DEVE ser APENAS uma string JSON representando uma lista de dicion√°rios, onde cada dicion√°rio cont√©m 'ingrediente' (string) e 'quantidade' (int, float ou null).
        N√ÉO inclua nenhum texto adicional, explica√ß√µes ou blocos de c√≥digo Markdown (```json).
        Exemplos de sa√≠da JSON:
        - Para "2 bananas, farinha de aveia e gotas de chocolate":
          [{"ingrediente": "banana", "quantidade": 2}, {"ingrediente": "farinha de aveia", "quantidade": null}, {"ingrediente": "gotas de chocolate", "quantidade": null}]
        - Para "ovos, leite e a√ß√∫car":
          [{"ingrediente": "ovo", "quantidade": null}, {"ingrediente": "leite", "quantidade": null}, {"ingrediente": "a√ß√∫car", "quantidade": null}]
        """,
        description="Agente que extrai ingredientes e quantidades de uma entrada de texto do usu√°rio."
    )

    entrada_agente = f"Texto de ingredientes: {texto_ingredientes}"
    saida_json_str = call_agent(agente_processador, entrada_agente)

    try:
        return json.loads(saida_json_str)
    except json.JSONDecodeError:
        print(f"Erro ao parsear JSON do Agente 1: '{saida_json_str}'")
        return []

#######################################################
# --- Agente 2: Gera√ß√£o de Consulta --- #
#######################################################
def agente_gerador_consultas(ingredientes_processados: list, tentativa: int = 1):
    # Converte a lista de ingredientes em uma string formatada para a instru√ß√£o
    nomes_ingredientes = ", ".join([ing["ingrediente"] for ing in ingredientes_processados])
    num_ingredientes = len(ingredientes_processados)

    # Ajusta a instru√ß√£o com base na tentativa para flexibilizar a busca
    flexibilidade_busca = ""
    if tentativa == 1:
        flexibilidade_busca = f" Gere consultas que busquem por receitas usando EXATAMENTE estes {num_ingredientes} ingredientes: {nomes_ingredientes}. Inclua termos como '{num_ingredientes} ingredientes' ou 'receita sem outros ingredientes'."
    elif tentativa == 2:
        flexibilidade_busca = f" Para esta tentativa, voc√™ pode ser um pouco menos restritivo. Busque receitas usando os ingredientes: {nomes_ingredientes}, mas esteja aberto a receitas com um ou dois ingredientes MUITO COMUNS adicionais (ex: sal, √°gua, fermento)."
    elif tentativa >= 3:
        flexibilidade_busca = f" Para esta √∫ltima tentativa, seja mais flex√≠vel. Busque receitas que CONTENHAM os ingredientes: {nomes_ingredientes}, mas que n√£o sejam excessivamente complexas."

    agente_gerador = Agent(
        name="agente_gerador_consultas",
        model=MODEL_ID,
        instruction=f"""
        Voc√™ √© um criador de consultas otimizado para o Google Search.
        Recebe uma string JSON representando uma lista de dicion√°rios com ingredientes e suas quantidades.
        Sua tarefa √© gerar uma lista de strings de consulta (at√© 4) para encontrar receitas no Google.
        Concentre-se em combina√ß√µes l√≥gicas dos ingredientes.
        Use termos como "receita", "como fazer", "prato com".
        As quantidades podem ser usadas para refinar, mas o principal √© a combina√ß√£o de ingredientes.
        {flexibilidade_busca}
        Sua sa√≠da DEVE ser APENAS uma string JSON representando uma lista de strings.
        N√ÉO inclua nenhum texto adicional, explica√ß√µes ou blocos de c√≥digo Markdown (```json).
        Exemplo de entrada: "[{{\"ingrediente\": \"banana\"}}, {{\"ingrediente\": \"farinha de aveia\"}}, {{\"ingrediente\": \"gotas de chocolate\"}}]"
        Exemplo de sa√≠da JSON (para 3 ingredientes): ["receita banana aveia gotas chocolate 3 ingredientes", "cookie banana aveia chocolate sem leite sem ovo", "bolo banana aveia gotas chocolate facil"]
        """,
        description="Agente que gera consultas de busca para o Google com base em ingredientes."
    )

    ingredientes_json_str = json.dumps(ingredientes_processados)
    entrada_agente = f"Ingredientes JSON: {ingredientes_json_str}"

    saida_json_str = call_agent(agente_gerador, entrada_agente)

    try:
        return json.loads(saida_json_str)
    except json.JSONDecodeError:
        print(f"Erro ao parsear JSON do Agente 2: '{saida_json_str}'")
        return []

#######################################################
# --- Agente 3: Buscador de Receitas --- #
#######################################################
def agente_buscador_receitas(consultas_de_busca: list):
    buscador_receitas = Agent(
        name="agente_buscador_receitas",
        model=MODEL_ID,
        instruction="""
        Voc√™ √© um assistente culin√°rio especialista. Sua tarefa √© usar a ferramenta de busca do Google (Google Search)
        para encontrar **at√© 4 receitas**.
        Tente encontrar resumos de receitas que listem claramente seus ingredientes, para facilitar a valida√ß√£o posterior.
        Sua sa√≠da DEVE ser APENAS uma string JSON representando uma lista de dicion√°rios. Cada dicion√°rio deve conter:
        'titulo' (string), 'url' (string), e 'resumo' (string). Se o resumo contiver ingredientes e modo de preparo, extraia-os.
        Se nenhuma receita for encontrada que se adeque, retorne um JSON de lista vazia [].
        N√ÉO inclua nenhum texto adicional, explica√ß√µes ou blocos de c√≥digo Markdown (```json).
        Exemplo de sa√≠da JSON (para entrada "banana, aveia"):
        [
            {"titulo": "Cookies de Banana e Aveia", "url": "https://example.com/cookies-banana", "resumo": "Cookies saud√°veis com 2 ingredientes. Ingredientes: 2 bananas maduras, 1 x√≠cara de aveia. Modo de preparo: Amasse as bananas e misture com a aveia..."}
        ]
        """,
        description="Agente que busca receitas no Google com base em consultas fornecidas.",
        tools=[google_search]
    )

    consultas_str = "\n".join(consultas_de_busca)
    entrada_agente = f"Consultas de busca:\n{consultas_str}"

    saida_json_str = call_agent(buscador_receitas, entrada_agente)

    try:
        return json.loads(saida_json_str)
    except json.JSONDecodeError:
        print(f"Erro ao parsear JSON do Agente 3: '{saida_json_str}'")
        return []

#######################################################
# --- Agente 4: Validador de Receitas --- #
#######################################################
def agente_validador_receitas(ingredientes_usuario: list, receitas_encontradas: list):
    agente_validador = Agent(
        name="agente_validador_receitas",
        model=MODEL_ID,
        instruction="""
        Voc√™ √© um validador de receitas EXTREMAMENTE RIGOROSO.
        Recebe uma lista de ingredientes que o usu√°rio possui (normalizados para singular e min√∫sculas)
        e uma lista de receitas encontradas, cada uma com 'titulo', 'url' e 'resumo'.
        Sua tarefa √© analisar o 'resumo' de CADA receita e determinar se ela utiliza SOMENTE OS INGREDIENTES
        DA LISTA DO USU√ÅRIO, ou um SUB-CONJUNTO EXATO desses ingredientes.

        VOC√ä DEVE IGNORAR COMPLETAMENTE: "√°gua", "sal", "pimenta", "fermento", "bicarbonato", "√≥leo" (apenas se for √≥leo gen√©rico de cozinha, n√£o espec√≠fico como "√≥leo de coco"), "azeite" (apenas se for gen√©rico), "vinagre", "temperos" (gen√©rico, como "cheiro verde", "especiarias"). Para todos os outros ingredientes, a correspond√™ncia DEVE ser EXATA.

        Se o resumo de uma receita mencionar QUALQUER OUTRO ingrediente SIGNIFICATIVO (ou seja, que n√£o est√° na lista do usu√°rio E n√£o √© um dos ingredientes b√°sicos ignor√°veis acima), essa receita DEVE ser IMEDIATAMENTE DESCARTADA.

        Sua sa√≠da DEVE ser APENAS uma string JSON representando uma lista de dicion√°rios,
        contendo APENAS as receitas que passaram na valida√ß√£o rigorosa.
        Se nenhuma receita passar na valida√ß√£o, retorne um JSON de lista vazia [].
        N√ÉO inclua nenhum texto adicional, explica√ß√µes ou blocos de c√≥digo Markdown (```json).

        Exemplo de entrada:
        Ingredientes do usu√°rio: [{"ingrediente": "banana"}, {"ingrediente": "farinha de aveia"}, {"ingrediente": "gotas de chocolate"}]
        Receitas encontradas:
        [
            {"titulo": "Cookies de Banana e Aveia e Gotas", "url": "...", "resumo": "Ingredientes: 2 bananas, 1 x√≠cara de aveia, 1/2 x√≠cara de gotas de chocolate. Modo de preparo..."},
            {"titulo": "Bolo de Banana com Ovos", "url": "...", "resumo": "Ingredientes: 2 bananas, 1 x√≠cara de aveia, 2 ovos. Modo de preparo..."},
            {"titulo": "Muffin de Banana e Aveia com Mel", "url": "...", "resumo": "Ingredientes: 2 bananas, 1 x√≠cara de aveia, 2 colheres de sopa de mel. Modo de preparo..."}
        ]

        Sa√≠da JSON esperada:
        [
            {"titulo": "Cookies de Banana e Aveia e Gotas", "url": "...", "resumo": "Ingredientes: 2 bananas, 1 x√≠cara de aveia, 1/2 x√≠cara de gotas de chocolate. Modo de preparo..."}
        ]
        """,
        description="Agente que valida se as receitas encontradas cont√™m apenas os ingredientes fornecidos pelo usu√°rio, de forma extremamente rigorosa."
    )

    # Prepara a entrada para o agente validador
    # Assegura que a lista de ingredientes do usu√°rio seja clara para o validador
    ingredientes_usuario_nomes = [i["ingrediente"] for i in ingredientes_usuario]
    ingredientes_usuario_para_validador = json.dumps([{"ingrediente": nome} for nome in ingredientes_usuario_nomes])

    receitas_json_str = json.dumps(receitas_encontradas)

    entrada_agente = f"Ingredientes do usu√°rio: {ingredientes_usuario_para_validador}\nReceitas encontradas: {receitas_json_str}"

    saida_json_str = call_agent(agente_validador, entrada_agente)

    try:
        return json.loads(saida_json_str)
    except json.JSONDecodeError:
        print(f"Erro ao parsear JSON do Agente Validador: '{saida_json_str}'")
        return []

#######################################################
# --- Agente 5: Apresentador de Receitas --- #
#######################################################
def agente_apresentador_receitas(receitas_encontradas: list):
    agente_apresentador = Agent(
        name="agente_apresentador_receitas",
        model=MODEL_ID,
        instruction="""
        Voc√™ √© um formatador de receitas para apresenta√ß√£o ao usu√°rio.
        Recebe uma string JSON representando uma lista de dicion√°rios, onde cada dicion√°rio cont√©m
        'titulo' (string), 'url' (string), e 'resumo' (string). O resumo pode conter ingredientes e modo de preparo.
        Sua tarefa √© formatar essas informa√ß√µes de maneira clara e leg√≠vel para o usu√°rio.
        Para cada receita, apresente no seguinte formato Markdown:
        ### Nome da Receita: [T√≠tulo da Receita]
        **Ingredientes:**
        [Lista de ingredientes extra√≠dos do resumo ou \"Ver na URL para detalhes.\"]

        **Modo de Preparo:**
        [Resumo do modo de preparo extra√≠do do resumo ou \"Ver na URL para detalhes.\"]

        **URL:** [https://www.gov.br/receitafederal/pt-br](https://www.gov.br/receitafederal/pt-br)

        Se n√£o houver receitas (lista JSON vazia), informe o usu√°rio com uma mensagem amig√°vel: \"N√£o foi poss√≠vel encontrar receitas que usem **apenas** os ingredientes informados ou um subconjunto deles. Tente ajustar sua lista de ingredientes ou ser menos espec√≠fico.\"
        N√ÉO inclua nenhum texto adicional al√©m da formata√ß√£o da receita ou da mensagem de n√£o encontrado.
        """,
        description="Agente que formata e apresenta as receitas encontradas para o usu√°rio."
    )

    receitas_json_str = json.dumps(receitas_encontradas)
    entrada_agente = f"Receitas encontradas (JSON):\\n{receitas_json_str}"

    resposta_formatada = call_agent(agente_apresentador, entrada_agente)

    display(Markdown(resposta_formatada))

# --- Exemplo de Fluxo de Execu√ß√£o (Orquestrador) ---
print("üöÄ Iniciando o Chatbot de Receitas üöÄ")

ingredientes_do_usuario = input("Por favor, digite os ingredientes que voc√™ tem em m√£os (ex: 2 bananas, farinha de aveia, gotas de chocolate): ")

if not ingredientes_do_usuario:
    print("Voc√™ esqueceu de digitar os ingredientes!")
else:
    print(f"Maravilha! Vamos buscar receitas com: {ingredientes_do_usuario}")

    print("\n--- üìù Resultado do Agente 1 (Processador de Ingredientes) ---\n")
    ingredientes_processados = agente_coleta_ingredientes(ingredientes_do_usuario)
    print(ingredientes_processados)
    print("--------------------------------------------------------------")

    if not ingredientes_processados:
        print("N√£o consegui identificar nenhum ingrediente. Por favor, tente novamente com mais detalhes.")
    else:
        MAX_TENTATIVAS = 3 # N√∫mero m√°ximo de tentativas de busca
        receitas_finais = []

        for tentativa in range(1, MAX_TENTATIVAS + 1):
            print(f"\n--- üîÑ Tentativa {tentativa} de {MAX_TENTATIVAS} (Gerador de Consultas) ---\n")
            consultas_geradas = agente_gerador_consultas(ingredientes_processados, tentativa)
            print(consultas_geradas)
            print("--------------------------------------------------------------")

            if not consultas_geradas:
                print("N√£o foi poss√≠vel gerar consultas de busca.")
                if tentativa == MAX_TENTATIVAS:
                    print("Todas as tentativas esgotadas sem sucesso na gera√ß√£o de consultas.")
                continue

            print(f"\n--- üîç Tentativa {tentativa} de {MAX_TENTATIVAS} (Buscador de Receitas) ---\n")
            receitas_encontradas = agente_buscador_receitas(consultas_geradas)
            print(f"Receitas encontradas pelo buscador nesta tentativa: {len(receitas_encontradas)}")
            # print(receitas_encontradas) # Descomente para ver o raw do buscador
            print("--------------------------------------------------------------")

            if not receitas_encontradas:
                print("Nenhuma receita encontrada para as consultas geradas nesta tentativa.")
                if tentativa == MAX_TENTATIVAS:
                    print("Todas as tentativas esgotadas sem encontrar receitas.")
                continue

            print(f"\n--- ‚úÖ Tentativa {tentativa} de {MAX_TENTATIVAS} (Validador de Receitas) ---\n")
            receitas_validadas = agente_validador_receitas(ingredientes_processados, receitas_encontradas)
            print(f"Receitas validadas nesta tentativa: {len(receitas_validadas)}")
            # print(receitas_validadas) # Descomente para ver o raw do validador
            print("--------------------------------------------------------------")

            if receitas_validadas:
                receitas_finais = receitas_validadas
                print(f"Encontramos {len(receitas_finais)} receita(s) v√°lida(s) na tentativa {tentativa}. Finalizando busca.")
                break # Sai do loop se encontrar receitas v√°lidas
            else:
                print("Nenhuma receita passou na valida√ß√£o rigorosa. Tentando novamente com consultas mais flex√≠veis...")

        print("\n--- üì£ Resultado Final (Apresentador de Receitas) ---\n")
        agente_apresentador_receitas(receitas_finais)
        print("--------------------------------------------------------------")

print("\nüéâ Chatbot de Receitas Conclu√≠do! üéâ")
